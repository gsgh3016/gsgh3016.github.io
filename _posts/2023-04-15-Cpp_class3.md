---
layout: single
title: í´ë˜ìŠ¤(Class)(3) ì¸í„°í˜ì´ìŠ¤(Interface)ë¡œì„œì˜ í´ë˜ìŠ¤ - 2
categories: C++
---

# 1. `static`

## 1-1 `static` vs `local` vs `global`

ê°€ì¥ í—·ê°ˆë¦¬ëŠ” ê°œë… ì¤‘ í•˜ë‚˜ê°€ ìœ„ ì„¸ í‚¤ì›Œë“œì˜ ì°¨ì´ì ì´ë‹¤. ê²°ë¡ ë¶€í„° ë§í•˜ìë©´ `static`ì€ ì»´íŒŒì¼ íƒ€ì„(compile-time)ì—ì„œ ë©”ëª¨ë¦¬ì— ì €ì¥(reserved)ë˜ê³ , ë‚˜ë¨¸ì§€ ë‘ í‚¤ì›Œë“œëŠ” `local`, `global`ì€ ëŸ°íƒ€ì„(runtime)ì—ì„œ ë©”ëª¨ë¦¬ì— ì €ì¥ëœë‹¤. C++ì€ ì»´íŒŒì¼ëŸ¬ ì–¸ì–´ì´ë¯€ë¡œ ì»´íŒŒì¼ íƒ€ì„ê³¼ ëŸ°íƒ€ì„ì´ ë¶„ë¦¬ëëŠ”ë°, ì´ë•Œë¬¸ì— `static` ì¸ìŠ¤í„´ìŠ¤ê°€ `global`ì²˜ëŸ¼ ë³´ì´ëŠ” ê²ƒì´ë‹¤.
<br>

---

## 1-2 `static` member

í´ë˜ìŠ¤ì—ì„œ `static`ì„ ì“°ëŠ” ê²½ìš°ëŠ” ë‘ê°€ì§€ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆë‹¤. ë©¤ë²„ í˜¹ì€ í´ë˜ìŠ¤ ìì²´ë¥¼ `static`ìœ¼ë¡œ ì¤„ ìˆ˜ ìˆë‹¤. ìš°ì„  ë©¤ë²„ë¥¼ ì£¼ëŠ” ê²½ìš°ë¥¼ ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```cpp
class StaticMemberClass {
	...
	static int staticMember;	// private, public ì—¬ë¶€ëŠ” ìƒê´€ ì—†ë‹¤
    ...
}

int StaticMemberClass::staticMember = 3;	// ì´ˆê¸°í™”ëŠ” global ìŠ¤ì½”í”„ë¡œ
```

ì—¬ê¸°ì„œ ì¡°ì‹¬í•  ë‚´ìš©ì€ **ì´ˆê¸°í™”ëŠ” ìŠ¤ì½”í”„ ì™¸ë¶€ì—ì„œ** ëœë‹¤ëŠ” ì ì´ë‹¤. ë§Œì•½ í´ë˜ìŠ¤ê°€ í—¤ë” íŒŒì¼ì— ì„ ì–¸ì´ ëë‹¤ë©´, ì™¸ë¶€ ì†ŒìŠ¤ íŒŒì¼ì—ì„œ ì´ˆê¸°í™”í•´ì•¼ í•œë‹¤.

ì´ì „ì— ì˜ˆì‹œë¥¼ ë“  ì§êµì¢Œí‘œê³„ë¥¼ ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```cpp
#include <iostream>
#include <vector>

class Point {
private:
    int x, y;
    static int pointCount;
public:
    Point(int x, int y) {
        this->x = x; this->y = y;
        Point::pointCount++;		// ìƒˆë¡œìš´ ê°ì²´ê°€ ìƒì„±ë ë•Œë§ˆë‹¤ 1ì”© ì¦ê°€
    }
    static int getPointCount(){		// staticì€ private, public ìƒê´€ì—†ì´ ì„ ì–¸ í•  ìˆ˜ ìˆë‹¤.
    	return Point::pointCount;	// this->pointCountê°€ ì•„ë‹ˆë‹¤.
    }
    void printPoint() {std::cout << "(" << this->x << ", " << this->y << ")" << std::endl;}
};

int Point::pointCount = 0;

int main() {
    std::vector<Point> points;

    for(int i=0; i<10; i++) {
        Point p(i, i);
        points.push_back(p);
        p.printPoint();
    }

	// static ë©¤ë²„ë¥¼ í˜¸ì¶œí•  ë•Œ private ë©¤ë²„ëŠ” ì—¬ì „íˆ í˜¸ì¶œí•  ìˆ˜ ì—†ë‹¤.
    // public ë©¤ë²„ëŠ” í´ë˜ìŠ¤::ë©¤ë²„ë¡œ í˜¸ì¶œí•œë‹¤.
    std::cout << "Point Count: " << Point::getPointCount() << std::endl;

    return 0;
}
```

![](https://velog.velcdn.com/images/gsgh3016/post/89e05f2c-f166-43e7-8141-19677a499e1e/image.png)

ìœ„ ì½”ë“œë¥¼ ê°„ë‹¨íˆ ë¦¬ë·°í•˜ìë©´, `point` ê°ì²´ê°€ ì„ ì–¸ë  ë•Œë§ˆë‹¤ ìƒì„±ì(constructor)ë¡œ `pointCount`ê°€ 1ì”© ì¦ê°€í•œë‹¤. ì»´íŒŒì¼ íƒ€ì„ì— `pointCount` ë³€ìˆ˜ê°€ í• ë‹¹ëìœ¼ë¯€ë¡œ, `pointCount` ëŠ” í´ë˜ìŠ¤ ìƒì„±/*ì†Œë©¸*ì— ìƒê´€ ì—†ì´ ë™ì‘í•œë‹¤.
<br>

---

# 2. ì‹±ê¸€í†¤(singleton)

`static` ì¸ìŠ¤í„´ìŠ¤ëŠ” ì‹œìŠ¤í…œì—ì„œ ìœ ì¼í•˜ë‹¤. ì»´íŒŒì¼ íƒ€ì„ì—ì„œ ë©”ëª¨ë¦¬ì— í• ë‹¹ë˜ê³  ëŸ°íƒ€ì„ë•ŒëŠ” ë‹¤ë¥¸ ê°ì²´ì™€ ê´€ë ¨ ì—†ì´ ì¡´ì¬í•œë‹¤.(ì´ˆê¸°í™”ëŠ” ëŸ°íƒ€ì„ì—ì„œ í•œë‹¤.) ê·¸ë ‡ë‹¤ë©´ í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ê°€ `static`í•œ ê²½ìš° ì¦‰, ê·¸ ì‹œìŠ¤í…œì—ì„œ ìœ ì¼í•œ ê²½ìš°ëŠ” ì–´ë–¨ê¹Œ? í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìœ ì¼í•˜ê²Œ ë§Œë“  ë””ìì¸ íŒ¨í„´ì´ ì‹±ê¸€í†¤ì´ë‹¤.
<br>

---

## 2-1 ì¥ë‹¨ì 

<table>
  <thead>
    <tr>
      <th>Pros ì¥ì </th>
      <th>Cons ë‹¨ì </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td colspan='2' style="text-align: center;">Global access: allowing all objects in the system to use the same instance
      	<br>
      	<b>ì‹œìŠ¤í…œ ë‚´ ëª¨ë“  ê°ì²´ê°€ ê°™ì€ ì¸ìŠ¤í„´ìŠ¤ì— ì ‘ê·¼</b>
      </td>
    </tr>
  	<tr>
      <td>Controlled access: 
        <br>multiple threads or processes need to access a shared resource.
      	<br>
      	<b>ë©€í‹° ìŠ¤ë ˆë“œ/í”„ë¡œì„¸ìŠ¤ê°€ ê³µìœ  ë¦¬ì†ŒìŠ¤ì— ì ‘ê·¼</b>
      </td>
      <td>Hidden dependencies:
        <br>all objects that depend on the Singleton instance must reference it directly.
      	<br>
      	<b>ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ì˜ì¡´ ê°ì²´ëŠ” ì§ì ‘ ì°¸ê³  í•´ì•¼í•¨.</b>
      </td>
    </tr>
    <tr>
      <td>Memory management:
        <br>ensuring that there is only one instance of the resource that is shared among multiple objects.
      	<br>
      	<b>ë‹¤ìˆ˜ ê°ì²´ê°€ ê³µìœ í•´ë„ ë¦¬ì†ŒìŠ¤ì— í•œ ì‹±ê¸€í†¤ ê°ì²´ë§Œ ì¡´ì¬í•¨.</b>
      </td>
      <td>Unit testing:
        <br>making it hard to substitute the Singleton instance with a mock object for testing.
      	<br>
      	<b>í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ ëŒ€ë¦¬ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë§Œë“¤ê¸° í˜ë“¦</b>
      </td>
    </tr>
    <tr>
      <td>Lazy initialization:
        <br>can be created lazily, can save memory and resources.
      	<br>
      	<b> ëŠ¦ê²Œ ë§Œë“¤ì–´ ì§ˆ ìˆ˜ ìˆì–´, ë©”ëª¨ë¦¬ì™€ ë¦¬ì†ŒìŠ¤ ì ˆì•½</b>
      </td>
      <td>Thread safety:
        <br>have to be accessed and modified correctly to avoid data races and synchronization issues.
      	<br>
      	<b> ë°ì´í„° ë ˆì´ìŠ¤ì™€ ë™ê¸°íšŒ ë¬¸ì œë¥¼ í”¼í•˜ê¸° ìœ„í•´ ì •í™•íˆ ì ‘ê·¼/ë³€ê²½í•´ì•¼ í•¨.</b>
      </td>
    </tr>
  </tbody>
</table>

<br>

---

## 2-2 íŒ¨í„´

```cpp
class Singleton {		// C++ëŠ” static í´ë˜ìŠ¤ë¥¼ ì„ ì–¸í•  ìˆ˜ ì—†ë‹¤. ê°ì²´ë§Œ ê°€ëŠ¥.

    static Singleton s;	// private/ public ë¬´ê´€í•˜ë‹¤.
    // ìƒì„±ì/ì†Œë©¸ì/ë³µì‚¬/ì´ë™ ì •ì˜ ê³ ë ¤
    // operator delete
    public:
    	Singleton& setSingleton(int a) {
        	static Singleton s
            // ë‹¤ë¥¸ private ë©¤ë²„ ì´ˆê¸°í™”
            return s;
        }
        ...
};
```

ì‹±ê¸€í†¤ í´ë˜ìŠ¤ë¥¼ ì œëŒ€ë¡œ ì´í•´í•˜ê¸° ìœ„í•´ì„œëŠ” ìƒì„±ì/ì†Œë©¸ìë¥¼ ì •í™•íˆ ì•Œì•„ì•¼ í•œë‹¤. ì‹±ê¸€í†¤ í´ë˜ìŠ¤ ê°ì²´ê°€ ì„ ì–¸ë˜ë©´, ì¼ë°˜ ê¸°ë³¸ ìƒì„±ìê°€ í˜¸ì¶œë˜ì–´ ê°ì²´ë¥¼ ìƒì„±í•œë‹¤. ë¬¸ë²•ìœ¼ë¡œ ë³´ê¸°ì—ëŠ” ë§ˆì¹˜ **ì¬ê·€(recursion)**ì™€ ê°™ì´ ê°ì²´ì™€ ë©¤ë²„ ê°ì²´ë¡œ ì½”ë“œê°€ êµ¬ì„±ëœë‹¤.

<div style="font: 16pt; font-weight: bold"> ë‚˜ â“ </div>

<h4> Imagine that class instance using singleton design pattern. if I deconstruct this instance, does static instance remain in stack</h4>

> #### ğŸ‡°ğŸ‡· ì‹±ê¸€í†¤ ë””ìì¸ íŒ¨í„´ì„ ì‚¬ìš©í•˜ëŠ” í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê°€ì •í•˜ì. ë‚´ê°€ ì´ ê°ì²´ë¥¼ ì†Œë©¸í•˜ë©´, `static` ì¸ìŠ¤í„´ìŠ¤ëŠ” ìŠ¤íƒ ì˜ì—­ì— ë‚¨ì•„ìˆëŠ”ê°€?

<details>
  <summary> ChatGPT â†©ï¸</summary>

In the singleton design pattern, there is only one instance of the class throughout the lifetime of the program, and it is typically implemented using a static member variable.

<q><h4> ğŸ‡°ğŸ‡· ì‹±ê¸€í†¤ íŒ¨í„´ì—ì„œëŠ” í”„ë¡œê·¸ë¨ ìˆ˜ëª…ë™ì•ˆ ì¸ìŠ¤í„´ìŠ¤ëŠ” í•˜ë‚˜ë§Œ ì¡´ì¬í•˜ë©° ì´ëŠ” í†µìƒ static ë©¤ë²„ ë³€ìˆ˜ë¡œ êµ¬í˜„ëœë‹¤. </h4></q>

<br>

When the program terminates or the singleton instance is destructed, the static instance is destroyed along with the rest of the static variables. This means that the memory used by the static instance is freed, and the variable is no longer accessible.

<q><h4> ğŸ‡°ğŸ‡· í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•˜ê±°ë‚˜ static ì¸ìŠ¤í„´ìŠ¤ê°€ ì†Œë©¸í•˜ë©´, ë‹¤ë¥¸ static ë³€ìˆ˜ì™€ ê°™ì´ íŒŒê´´ëœë‹¤. ì´ ë§ì€<br> &emsp; 1. static ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ë©”ëª¨ë¦¬ê°€ í•´ì œë˜ê³ ,<br> &emsp; 2. ë³€ìˆ˜ì— ë” ì´ìƒ ì ‘ê·¼í•  ìˆ˜ ì—†ìŒ<br> &emsp; ì„ ì˜ë¯¸í•œë‹¤.</h4></q>

  <br>

If the singleton instance is destructed explicitly by calling its destructor, the static instance is also destructed along with it. If the singleton instance is destructed implicitly, such as when the program terminates, the static instance is also destructed along with all the other static variables.

<q><h4> ğŸ‡°ğŸ‡· ì†Œë©¸ì í˜¸ì¶œë¡œ ëª…ì‹œì ìœ¼ë¡œ ì†Œë©¸í•˜ë©´, static ì¸ìŠ¤í„´ìŠ¤ë„ ê°™ì´ ì†Œë©¸í•œë‹¤. í”„ë¡œê·¸ë¨ ì¢…ë£Œì™€ ê°™ì´ ì•”ë¬µì ìœ¼ë¡œ ì†Œë©¸í•˜ë©´ ë‹¤ë¥¸ static ë³€ìˆ˜ì™€ ê°™ì´ static ì¸ìŠ¤í„´ìŠ¤ë„ ê°™ì´ ì†Œë©¸í•œë‹¤.</h4></q>

<br>

However, it is important to note that if the singleton instance creates any dynamically allocated memory or resources, those resources must also be released before the instance is destroyed. Failure to do so can result in memory leaks or other issues.

<q><h4> ğŸ‡°ğŸ‡· ë§Œì•½ ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ê°€ ë™ì  í• ë‹¹ëœ ë©”ëª¨ë¦¬ë‚˜ ë¦¬ì†ŒìŠ¤ì— ë§Œë“¤ì–´ì¡Œì„ ê²½ìš°, ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì—†ì• ê¸° ì „ ì´ëŸ° ë¦¬ì†ŒìŠ¤ë¥¼ í•´ì œí•´ì•¼ í•œë‹¤. ì˜ëª»í•˜ë©´ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë‚˜ ë‹¤ë¥¸ ë¬¸ì œê°€ ìƒê¸¸ ìˆ˜ ìˆë‹¤.</h4></q>

<br>

In summary, when a singleton instance is destructed, its static member variable is also destroyed and the memory used by the variable is freed.

> <h4> ğŸ‡°ğŸ‡· ìš”ì•½í•˜ìë©´, ì‹±ê¸€í†¤ ê°ì²´ê°€ ì†Œë©¸í•  ë•Œ, ```static``` ë©¤ë²„ ë³€ìˆ˜ ë˜í•œ ì—†ì–´ì§€ê³  ë©”ëª¨ë¦¬ëŠ” í•´ì œëœë‹¤.</h4>

<br>

</details>

ì•„ì§ ìƒì„±ìì™€ ì†Œë©¸ì, ë³µì‚¬, ì´ë™, ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì— ëŒ€í•œ ê³µë¶€ê°€ ë¶€ì¡±í•´ì„œ ìì„¸í•œ ë‚´ìš©ì€ í–¥í›„ í¬ìŠ¤íŒ…ì—ì„œ ë‹¤ë£° ì˜ˆì •ì´ë‹¤.
<br>

---

# 3. ë¹Œë”(builder)

í´ë˜ìŠ¤ì— ì´ˆê¸°í™”í•  ë‚´ìš©ì´ ë„ˆë¬´ ë§ì„ ê²½ìš°ì—ëŠ” ì–´ë–¨ê¹Œ? í˜¹ì€ ê°™ì€ ë‚´ìš©ìœ¼ë¡œ ë‹¤ë¥¸ ê°ì²´ë¥¼ ë§Œë“ ë‹¤ë©´? ë¹Œë”ëŠ” ì¸ìŠ¤í„´ìŠ¤ ìƒì„±ì„ ìœ„í•œ ì¼ì¢…ì˜ **ì¡°ë¦½ ì„¤ëª…ì„œ** ê°ì²´ì´ë‹¤.
![builder](https://velog.velcdn.com/images/gsgh3016/post/a75f5b7e-9807-49c7-8f6a-e54e0421948c/image.png)
ìœ„ ì‚¬ì§„ìœ¼ë¡œ ì˜ˆì‹œë¥¼ ë“¤ë©´ method1ì€ instanceì˜ component1ì„ ì´ˆê¸°í™”í•˜ê³  method2ëŠ” component2ë¥¼ method3ì€ component3ì„ ì´ˆê¸°í™”í•œë‹¤. ì´ë¥¼ ì½”ë“œë¡œ ë‚˜íƒ€ë‚´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

ë¹Œë” íŒ¨í„´ì—ì„œ ì¡°ë¦½í’ˆì€ ì—¬ëŸ¬ê°€ì§€ì´ì§€ë§Œ, ì¡°ë¦½ ì„¤ëª…ì„œëŠ” ìœ ì¼í•˜ê¸° ë•Œë¬¸ì— ì‹±ê¸€í†¤/ëª¨ë…¸ìŠ¤í…Œì´íŠ¸ë¡œ ë¹Œë”ë¥¼ ë””ìì¸í•˜ê¸°ë„ í•œë‹¤.
<br>

---

## 3-1 ì¥ë‹¨ì 

<table>
    <thead>
        <tr>
            <th>Pros</th>
            <th>Cons</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Provides a clear separation of concerns between the construction process and the representation of the object being constructed.<br>
              <b>ìƒì„± ê³¼ì •ê³¼ ìƒì„±ëœ ê°ì²´ì˜ í‘œí˜„ì„ ëª…í™•í•˜ê²Œ êµ¬ë¶„</b>
          </td>
            <td>Increases code complexity by requiring the creation of additional classes and interfaces.<br>
              <b>ì¶”ê°€ í´ë˜ìŠ¤ì™€ ì¸í„°í˜ì´ìŠ¤ê°€ í•„ìš” -> ì½”ë“œê°€ ë³µì¡í•´ì§„ë‹¤.</b>
          </td>
        </tr>
        <tr>
            <td>Allows for more readable and maintainable code by providing a step-by-step approach to creating an object.<br>
              <b>ê°ì²´ë¥¼ ë§Œë“¤ë•Œ ë‹¨ê³„ë³„ ì ‘ê·¼ -> ìœ ì§€/ë³´ìˆ˜ì— ìš©ì´í•˜ê³  ê°€ë…ì„±ì´ ì¢‹ìŒ</b>
          </td>
            <td>Can be overkill for simple object creation scenarios, where the object can be easily constructed using a constructor.<br>
              <b>ì‰¬ìš´ ìƒì„±ìì—ì„œ ë¹Œë“œ ì‚¬ìš©ì€ ê³¼ë„í•¨</b>
          </td>
        </tr>
        <tr>
            <td>Provides more control over the object creation process by allowing the construction of complex objects to be broken down into smaller, more manageable steps.<br>
              <b>ë³µì¡í•œ ê°ì²´ ìƒì„±ë¥¼ ë‹¨ê³„ë³„ë¡œ ìª¼ê°¬ -> ê° ë‹¨ê³„ê°€ ë‹¤ë£¨ê¸° ì‰¬ì›Œì§€ê³  ìƒì„± ê³¼ì •ì„ ì œì–´í•  ìˆ˜ ìˆìŒ</b>
          </td>
            <td>Requires more code to be written, which may result in increased development time and cost.<br>
              <b>ë” ë§ì´ ì½”ë“œë¥¼ ì‘ì„±í•´ì•¼í•¨ -> ê°œë°œ ì‹œê°„, ë¹„ìš©ì´ ì¦ê°€í•¨</b>
          </td>
        </tr>
        <tr>
            <td>Provides flexibility in the order and type of construction steps by allowing different variations of the object to be created.<br>
              <b>ê°ì²´ ìƒì„±ì— ë³€ì£¼ë¥¼ ì¤„ ë•Œ ìœ ì—°ì„± ì¦ê°€</b>
          </td>
            <td>May not be suitable for all object creation scenarios, particularly those where the construction of the object is not complex or where the order of construction steps is fixed.<br>
              <b>ê°ì²´ê°€ ë³µì¡í•˜ì§€ ì•Šê±°ë‚˜, ìƒì„± ê³¼ì •ì´ ê³ ì •ëœ ê°ì²´ì—ëŠ” ì í•©í•˜ì§€ ì•ŠìŒ</b>
          </td>
        </tr>
    </tbody>
</table>

<br>

---

## 2-2 íŒ¨í„´

```cpp
class instance {
private:
	int component1, component2, component3;
public:
	friend class builder;
}

class builder {
private:
	instance inst;
public:
	builder& method1(int a) {
    	this->inst.component1 = a;
        return *this;
    }
	builder& method2(int b) {
    	this->inst.component2 = b;
        return *this;
    }
	builder& method3(int c) {
    	this->inst.component3 = c;
        return *this;
    }
}

int main() {
	...
    builder b;
    b.method1(1).method2(2).method3(3);
    ...
}
```

<div style="font: 16pt; font-weight: bold">ë‚˜ â“</div>

<h4>what is the situation needed multiple builder process in single instance?</h4>

> #### ğŸ‡°ğŸ‡· í•œ ê°ì²´ë¥¼ ë‹¤ë¥¸ ë¹Œë”ë¡œ ì§€ì–´ì•¼ í•  ê²½ìš°ëŠ” ì–´ë–¤ ìƒí™©ì¸ê°€?

<details>
  <summary> ChatGPT â†©ï¸</summary>

The situation where multiple builder processes are needed for a single instance typically arises when the object being constructed has multiple configuration options or variations that need to be set during the construction process.
<br>

ğŸ‡°ğŸ‡· êµ¬ì„± ì˜µì…˜,ë³€ìˆ˜ê°€ ë§ì•„ ìƒì„± ê³¼ì •ì—ì„œ ì„¤ì •ë¼ì•¼í•˜ëŠ” ê²½ìš°ì´ë‹¤.

<br>
<br>

For example, consider a car manufacturing factory that produces cars with different configurations and options such as engine type, transmission, interior finish, and exterior color. To create a car with a specific set of options, multiple builders may be needed to construct the different components of the car, and then assemble them together into a final product.
<br>

ğŸ‡°ğŸ‡· ì˜ˆì‹œ 1. ìë™ì°¨ ìƒì‚° ê³µì¥<br> &emsp; ìë™ì°¨ ìƒì‚°ì— ì˜µì…˜ì´ ë§ìŒ; ì—”ì§„ ì¢…ë¥˜, ë³€ì†ê¸°, ì¸í…Œë¦¬ì–´ ë§ˆê°, ì™¸ë¶€ ìƒ‰ìƒ <br>ì—¬ëŸ¬ ê°€ì§€ ì˜µì…˜ì„ ë§Œì¡±í•˜ëŠ” ìë™ì°¨ë¥¼ ìƒì‚°í•˜ê¸° ìœ„í•´ ì—¬ëŸ¬ê°€ì§€ ë¹Œë”ê°€ í•„ìš”í•˜ë‹¤. ê·¸ë¦¬ê³  ì˜µì…˜ì„ ì¡°ë¦½í•´ ìµœì¢… ì™„ì„±í’ˆìœ¼ë¡œ ë§Œë“ ë‹¤.
<br>
<br>

Another example is when constructing a complex data structure, such as a tree or a graph, where each node or vertex can have different attributes and properties. In this case, multiple builders may be needed to create different nodes or vertices with specific properties, and then link them together to form the final data structure.
<br>

ğŸ‡°ğŸ‡· ì˜ˆì‹œ 2. ë³µì¡í•œ ë°ì´í„° êµ¬ì¡°ë¥¼ ìƒì„±í•  ë•Œ<br> &emsp; ê° ë…¸ë“œ, ê¼­ì§“ì  ë³„ë¡œ ê³ ìœ  ì„±ì§ˆ, ì†ì„±ì„ ê°€ì§„ë‹¤. ì´ëŸ´ ê²½ìš° íŠ¹ì§•ì— ë§ëŠ” ë¹Œë”ê°€ í•„ìš”í•˜ë‹¤. ê·¸ë¦¬ê³  ê°ê° ë…¸ë“œ/ê¼­ì§“ì ì„ ì´ì–´ ë°ì´í„° êµ¬ì¡°ë¥¼ í˜•ì„±í•œë‹¤.

<br>
<br>

In both of these scenarios, the use of multiple builders can help simplify the construction process and make it more modular and flexible, allowing for different variations of the object to be created easily.
<br>
ğŸ‡°ğŸ‡· ê° ì˜ˆì‹œì—ì„œ ë‹¤ì–‘í•œ ë¹Œë”ëŠ” ìƒì„± ê³¼ì •ì„ ë‹¨ìˆœí•˜ê²Œ ë§Œë“¤ê³ , ê° ê³¼ì •ì´ ëª¨ë“ˆì‹ì´ë©° ìœ ì—°í•˜ë‹¤. ë”°ë¼ì„œ ë‹¤ë¥¸ ë³€ì£¼ë¥¼ ì£¼ëŠ” ê°ì²´ë¥¼ ì‰½ê²Œ ìƒì„±í•  ìˆ˜ ìˆë‹¤.

<br>
<br>

</details>
